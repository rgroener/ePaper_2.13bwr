
#ifndef F_CPU
#define F_CPU 16000000UL
#endif
#include <stdlib.h>
#include <stdint.h>
#include <avr/io.h>
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
 

#define START_PARTIAL_MODE epap_send_command(0x91)
#define START_NORMAL_MODE epap_send_command(0x92)

#define BLACK 	0
#define RED		1
#define WHITE	2

#define BUSY_LOW !(PIND & (1<<PD0))		//check if display is busy
#define CS_LOW PORTC &= ~(1<<PC1)		//set cs low
#define CS_HIGH PORTC |= (1<<PC1)		//set cs high

#define SEND_DATA PORTC |= (1<<PC0)		//send data to display
#define SEND_COMMAND PORTC &= ~(1<<PC0)	//send command to display

#define LED_EIN PORTD |= (1<<PD1)
#define LED_AUS PORTD &= ~(1<<PD1)

void spi_init(void);
unsigned char epap_send_data(unsigned char data);
unsigned char epap_send_command(unsigned char data);
void epap_fill_full(uint8_t color);
void epap_fill_part(uint8_t hor_start, uint8_t hor_stop, uint8_t vert_start, uint8_t vert_stop, uint8_t color);
void epap_init(void);
void epap_refresh(void);
void epap_write_data(uint16_t lenght,uint8_t color, uint8_t *buffer);
void epap_set_part_window(uint8_t hor_start, uint8_t hor_stop, uint8_t vert_start, uint8_t vert_stop, uint8_t scan);
void epap_draw_image(uint8_t with, uint8_t hight, uint8_t x, uint8_t y, uint8_t color, uint8_t *image, uint8_t refresh);
void epap_wait(void);


uint8_t image[800]={
	//80x80 [800] Woodstock
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfa, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xbf, 0xee, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x76, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xb5, 0xba, 0xeb, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9e, 0xdc, 0x5e, 0x8f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x97, 0xe8, 0xf5, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9a, 0xbc, 0xbe, 0x3b, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x9f, 0x68, 0xd6, 0x2f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xca, 0xf4, 0x78, 0x5f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x9f, 0xac, 0x54, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc5, 0x78, 0xf8, 0x5f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x87, 0xaf, 0xac, 0x77, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0x7a, 0xf6, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe1, 0xd7, 0xae, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x7d, 0x7b, 0x87, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xfc, 0x57, 0xdd, 0x41, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7a, 0xb7, 0xb0, 0x07, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xfe, 0x2f, 0xed, 0xda, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x75, 0x5b, 0x6d, 0xb0, 0x0f, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x3f, 0xf6, 0xbb, 0xdf, 0x03, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x6a, 0xaf, 0x16, 0xb5, 0xc3, 0xff, 0xff, 
0xff, 0xf0, 0x10, 0xdd, 0xfb, 0x1f, 0xff, 0x70, 0xff, 0xff, 0xff, 0xe2, 0x05, 0xee, 0xad, 0x15, 0x55, 0xd8, 0xff, 0xff, 
0xff, 0xe7, 0xbf, 0x5b, 0xde, 0x1e, 0xee, 0xec, 0xff, 0xff, 0xff, 0xca, 0xea, 0xf6, 0xf5, 0x2b, 0xbb, 0x74, 0x7f, 0xff, 
0xff, 0x8f, 0x77, 0xbb, 0x5f, 0x3d, 0x6d, 0xbc, 0xff, 0xff, 0xff, 0x9b, 0xad, 0x6e, 0xea, 0xeb, 0xdf, 0xd4, 0x5f, 0xff, 
0xff, 0x96, 0xff, 0xdb, 0xbf, 0xbe, 0xf5, 0x78, 0xff, 0xff, 0xff, 0x8b, 0x54, 0xb6, 0xea, 0xeb, 0x5d, 0xa8, 0xbf, 0xff, 
0xff, 0xdd, 0xf9, 0xfd, 0xbd, 0xbd, 0xeb, 0xe1, 0xff, 0xff, 0xff, 0xf7, 0x51, 0x57, 0x6b, 0xd7, 0x5e, 0xa2, 0xff, 0xff, 
0xff, 0xff, 0xf1, 0xed, 0xde, 0xba, 0xf4, 0x07, 0xbf, 0xff, 0xff, 0xfe, 0xa1, 0x77, 0x75, 0xef, 0xa8, 0x0a, 0xff, 0xff, 
0xff, 0xff, 0xc3, 0xbb, 0xbf, 0x5a, 0x80, 0x2f, 0xff, 0xff, 0xff, 0xff, 0x02, 0xdd, 0x6a, 0xf6, 0x01, 0xf5, 0xff, 0xff, 
0xff, 0xff, 0x05, 0xeb, 0xdf, 0xbc, 0x0b, 0x5f, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x5e, 0xea, 0xd0, 0x1d, 0xff, 0xff, 0xff, 
0xff, 0xfe, 0x1a, 0xf7, 0x7d, 0xb8, 0x2b, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0x3d, 0xa8, 0x07, 0x68, 0x7f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xeb, 0x41, 0x01, 0xf8, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x1e, 0xa0, 0x50, 0xf7, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf7, 0xf8, 0xf8, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdd, 0x58, 0x54, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfe, 0x6c, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x38, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfe, 0x6c, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x34, 0x5f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xfc, 0x7e, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xd5, 0x1f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf8, 0x7b, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xd5, 0x8f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf1, 0xbd, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xf3, 0x94, 0x8b, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x3f, 0xf2, 0xc9, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe2, 0x9f, 0xf3, 0x4c, 0x8b, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xc7, 0x47, 0xf1, 0xce, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcb, 0xe3, 0xc0, 0x94, 0x8f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x8d, 0x58, 0x00, 0x4c, 0xb7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xb4, 0x06, 0x11, 0xaf, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x35, 0x7f, 0xd6, 0x06, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2f, 0xd5, 0x3b, 0x05, 0x5b, 0xff, 0xff, 0xff, 
0xff, 0xfe, 0x7a, 0xb0, 0x5e, 0x32, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0x2f, 0xc1, 0x6e, 0xe2, 0x00, 0x0f, 0xff, 0xff, 
0xff, 0xfe, 0x75, 0x1e, 0xde, 0x51, 0x00, 0x87, 0xff, 0xff, 0xff, 0xfe, 0x2c, 0x57, 0x7e, 0x60, 0x3f, 0xc3, 0xff, 0xff, 
0xff, 0xfe, 0x00, 0xfd, 0xfe, 0x60, 0x00, 0xaf, 0xff, 0xff, 0xff, 0xff, 0x07, 0x57, 0x5c, 0x1e, 0x00, 0x76, 0xff, 0xff, 
0xff, 0xff, 0x6a, 0xfe, 0x00, 0x9b, 0xda, 0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x6b, 0x76, 0xbc, 0x1f, 0xff, 0xff, 
0xff, 0xff, 0xdb, 0xf8, 0x3d, 0xdd, 0xd2, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0xbf, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xc2, 0xa2, 0x57, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xdf, 0xba, 0xef, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0xb7, 0x7a, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

void epap_write_dummy(uint16_t lenght)
{
	uint16_t xx=0;
	//Display transmission 1 (b/w pixel)
	epap_send_command(0x10);
	for(xx=0; xx<lenght;xx++)
	{
		//1=white 0=black
		epap_send_data(0x00);
	}
	//end sendet data
	epap_send_command(0x11);	
	//Display transmission 2 (red pixel)
	epap_send_command(0x13);
	for(xx=0; xx<lenght;xx++)
	{
		//0=red  1=transp
		epap_send_data(0xFF);
		
	}
	//end sendet data
	epap_send_command(0x11);
	//epap_send_command(0x12);
	//while(BUSY_LOW);
}

int main(void)
{
	DDRD |= (1<<PD1);//output led

	spi_init();
    sei();
	epap_init();
	START_NORMAL_MODE;
	epap_fill_full(WHITE);
	
	epap_draw_image(80,80,1,10, BLACK, image, 1);
	
	
	epap_set_part_window(3,8,100,150,1);
	epap_write_dummy(1000);
	epap_refresh();
	LED_EIN;
	
	while(1)
	{ 
			
	} //end while
}//end of main

void epap_init(void)
{
	//booster soft start
	epap_send_command(0x06);
	epap_send_data(0x17);
	epap_send_data(0x17);
	epap_send_data(0x17);
	
	/*
	//Power setting
	epap_send_command(0x01);
	epap_send_data(0x03);
	epap_send_data(0x00);
	epap_send_data(0x2b);
	epap_send_data(0x2b);
	epap_send_data(0x09);
*/
	
	//Panel setting
	epap_send_command(0x00);
	epap_send_data(0x8F);
	//Vcom and data interval setting
	epap_send_command(0x50);
	epap_send_data(0x37);
	
	//Resolution setting
	epap_send_command(0x61);
	epap_send_data(0x68);
	epap_send_data(0x00);
	epap_send_data(0xD4);
/*
	//VCM DC setting
	epap_send_command(0x82);
	epap_send_data(0x12);
	//Pll control
	epap_send_command(0x03);
	epap_send_data(0x3a);
*/
	//Power on
	epap_send_command(0x04);
	while(BUSY_LOW);
	//epap_clear_white();
};

void epap_wait(void)
{
	while(BUSY_LOW);//wait as long as display busy
}

void epap_refresh(void)
{
	epap_send_command(0x12);
	while(BUSY_LOW);
}

void epap_write_data(uint16_t lenght, uint8_t color, uint8_t *buffer)
{
	uint16_t xx=0;
	//Display transmission 1 (b/w pixel)
	epap_send_command(0x10);
	for(xx=0; xx<lenght;xx++)
	{
		//1=white 0=black
		if(color==0)
		{
			epap_send_data(buffer[xx]);	//write data to b/w ram
		}else epap_send_data(0xFF);		//white background if data in red
	}
	//end sendet data
	epap_send_command(0x11);	
	//Display transmission 2 (red pixel)
	epap_send_command(0x13);
	for(xx=0; xx<lenght;xx++)
	{
		//0=red  1=transp
		if(color==1)
		{
			epap_send_data(buffer[xx]);
		}else epap_send_data(0xFF);
		
	}
	//end sendet data
	epap_send_command(0x11);
	//epap_send_command(0x12);
	//while(BUSY_LOW);
}

//Function to send and receive data for both master and slave
unsigned char epap_send_data(unsigned char data)
{
	CS_LOW;
	SEND_DATA;
    // Load data into the buffer
    SPDR = data;
 
    //Wait until transmission complete
    while(!(SPSR & 0x80 ));

	CS_HIGH;
    // Return received data
    return(SPDR);
    
}
//Function to send and receive data for both master and slave
unsigned char epap_send_command(unsigned char data)
{
	CS_LOW;
	SEND_COMMAND;
    // Load data into the buffer
    SPDR = data;
 
    //Wait until transmission complete
    while(!(SPSR & 0x80 ));
	
	CS_HIGH;
    // Return received data
    return(SPDR);
    
}

void epap_fill_full(uint8_t color)
{
	uint16_t xx=0;
	//Display transmission 1 (b/w pixel)
	epap_send_command(0x10);
	for(xx=0; xx<2756;xx++)
	{
		if(color==0)	//=0 black 1=red 2=white
		{
			epap_send_data(0x00);
		}else epap_send_data(0xFF);
	}
	//end sendet data
	epap_send_command(0x11);	
	//Display transmission 2 (red pixel)
	epap_send_command(0x13);
	for(xx=0; xx<2756;xx++)
	{
		if(color==1)
		{
			epap_send_data(0x00);	//red
		}else epap_send_data(0xFF);	//transp
	}
	epap_send_command(0x11);	//End data transmission
	epap_refresh();
	while(BUSY_LOW);
}

void epap_fill_part(uint8_t hor_start, uint8_t hor_stop, uint8_t vert_start, uint8_t vert_stop, uint8_t color)
{
	uint16_t xx=0;
	uint16_t leng=0;
	epap_send_command(0x91);	//set partial mode
	epap_set_part_window(vert_start,vert_stop,hor_start,hor_stop,0);
	
	leng = (vert_stop - vert_start) * (hor_stop-hor_start);
	
	//Display transmission 1 (b/w pixel)
	epap_send_command(0x10);
	for(xx=0; xx<leng;xx++)
	{
		if(color==0)
		{
			epap_send_data(0x00);
		}else epap_send_data(0xFF);
	}
	//end sendet data
	epap_send_command(0x11);	
	//Display transmission 2 (red pixel)
	epap_send_command(0x13);
	for(xx=0; xx<leng;xx++)
	{
		if(color==1)
		{
			epap_send_data(0x00);
		}else epap_send_data(0xFF);
		
	}
	epap_send_command(0x11);	//End data transmission
	epap_refresh();
	while(BUSY_LOW);
}


void epap_set_part_window(uint8_t hor_start, uint8_t hor_stop, uint8_t vert_start, uint8_t vert_stop, uint8_t scan)
{
	epap_send_command(0x91);	//set partial mode
	//partial window (Ram area)
	//bit shifting according datasheet 
	//(32) Partial Window(PTL)
	epap_send_command(0x90);
	epap_send_data(hor_start<<3);
	epap_send_data(hor_stop<<3);
	epap_send_data(vert_start>>8);
	epap_send_data(vert_start);
	epap_send_data(vert_stop>>8);
	epap_send_data(vert_stop);
	if(scan==1)
	{
		epap_send_data(0x01);//Gates scan only outside of the window (default)
	}else epap_send_data(0x00);//Gates scan only inside of the window
}

void epap_draw_image(uint8_t with, uint8_t hight, uint8_t x, uint8_t y, uint8_t color, uint8_t *image, uint8_t refresh)
{
	epap_send_command(0x91);								//start partial mode
	epap_set_part_window(x,(x+(with/8))-1,y, y+hight, 0); 	//set partial window according image
	epap_write_data((with/8)*hight,color, image);					//send data to display
	if(refresh)
	{
		epap_refresh();										//refresh in partial mode
		epap_wait();											//display busy
	}
	//epap_send_command(0x92); 								//stop partial mode
}


// Initialize SPI Master Device (with SPI interrupt)
void spi_init(void)
{
    // Set MOSI, SCK as Output
    DDRB=(1<<5)|(1<<3);
	DDRC = ((1<<PC0) | (1<<PC1));//Output
	PORTC = ((1<<PC0) | (1<<PC1));//set high
	DDRB &= ~(1<<PB4);//Input (Miso)
	DDRD &= ~(1<<PD0);//Input
	//PORTD |= (1<<PD0);//epaper-BUSY; activate pullup
    // Enable SPI, Set as Master
    // Prescaler: Fosc/16, Enable Interrupts
    //The MOSI, SCK pins are as per ATMega8
    // Enable SPI as master, set clock rate fck/2
    SPCR = (1<<SPE) | (1<<MSTR);
    SPSR = (1<<SPI2X);
 
    // Enable Global Interrupts
    sei();
}
void spi_close()
{
	SPCR = 0x00;//clear spi enable bit
}

